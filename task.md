Okay, this is a significant task requiring careful planning to integrate the web search results seamlessly, mimicking the Grok 3 UI, without disrupting Chatkuka's existing functionality. The AI Agent needs extreme detail.

Here is the very detailed Markdown checklist:

```markdown
# Project Plan: Integrate Web Search Results Seamlessly

**Goal:** Modify the existing Tavily web search integration to display results similarly to the Grok 3 reference UI. This involves:
1.  Instructing the AI to synthesize information from search results and cite them inline within its response.
2.  Updating the frontend to capture search data streamed from the backend.
3.  Associating the captured search data with the specific assistant message generated using that data.
4.  Rendering a redesigned `SearchResults` component *after* the relevant assistant message content.
5.  Displaying search progress indicators appropriately.
6.  Rendering inline citations (`[Source Title](URL)`) generated by the AI correctly.
7.  Ensuring no existing functionality (chat, artifacts, auth, payments, etc.) is broken.

---

## Story 1: Enhance Backend API for Integrated Search & Citation

**Context:** The backend API route (`app/(chat)/api/chat/route.ts`) currently performs the Tavily search and streams status/results. It needs to provide clearer instructions to the AI on how to use and cite these results within its primary response.
**Constraint:** Must not interfere with non-search chat requests, other tool usage (getWeather, documents), or artifact generation logic. Must maintain existing streaming data types (`search-status`, `search-results`).

**Requirements:**
- Modify the system prompt specifically when `useSearch` is true.
- Inject search results effectively into the system prompt.
- Add explicit, mandatory instructions for inline citation using `[Title](URL)` format.
- Instruct the AI to synthesize information, not just list sources.
- Ensure existing data streaming (`search-status`, `search-results`) remains functional.
- Maintain compatibility with different AI models selected by the user.

**Tasks:**

-   [ ] **File:** `app/(chat)/api/chat/route.ts`
    -   [ ] Locate the section where `systemMessage` is constructed when `useSearch` is true and `searchResults` are available.
    -   [ ] **After** appending the formatted search results (`Sources:\nSource X: ...`) to `systemMessage`, add the following explicit instruction block:
        ```typescript
        systemMessage += `\n\nIMPORTANT: When referencing information from the above search results in your response, you MUST cite the corresponding source(s) using this exact markdown format: [Source Title](URL).`;
        systemMessage += ` For example: "According to [Example Source Title](https://example.com), the sky is blue." Do NOT just list URLs. Cite them inline where the information is used. Synthesize the information from the sources to answer the user's query comprehensively.\n\n`;
        ```
    -   [ ] Ensure the prompt also instructs the AI on how to behave if search results are empty or if an error occurred during search (based on the existing logic that appends error/no-result messages to `systemMessage`).
    -   [ ] Verify the final, modified `systemMessage` is correctly passed to the `streamText` function's `system` parameter.
    -   [ ] Confirm `maxSteps: 5` (or a similar sufficient value > 1) is set in the `streamText` call to allow for tool call + response generation.
    -   [ ] Add `console.log` before the `streamText` call to output the *complete* `systemMessage` being used when search is active (for debugging).
    *   [ ] Review the existing `dataStream.writeData` calls for `search-status` and `search-results`. Ensure they are still being sent correctly *before* the `streamText` call initiates the AI response generation.
    *   [ ] Verify error handling for the `searchTavily` call correctly sends a `search-status` type 'error' via `dataStream.writeData`.

---

## Story 2: Manage Search State on Frontend & Associate with Messages

**Context:** The frontend needs to capture the `search-status` and `search-results` data streamed from the backend and correctly link the final `search-results` data to the specific assistant message that was generated using those results.
**Constraint:** Leverage the existing `useChat` hook and its capabilities (`experimental_onData`, `onFinish`, `setMessages`). Avoid introducing complex global state if possible.

**Requirements:**
- Capture custom data streamed via `experimental_onData`.
- Store the *latest* search status/results temporarily while the AI response streams.
- Attach the final search results data to the corresponding assistant message object upon completion (`onFinish`).
- Differentiate between ongoing search progress and final results associated with a message.

**Tasks:**

-   [ ] **File:** `components/chat.tsx` (or wherever `useChat` is primarily used)
    -   [ ] Define or import TypeScript interfaces `SearchData` (matching the structure sent by `dataStream.writeData`) and `MessageWithSearchData` (extending `Message` to include `data?: { search?: SearchData }`).
    -   [ ] Introduce a `useState` hook: `const [currentSearchData, setCurrentSearchData] = useState<SearchData | null>(null);`
    -   [ ] Implement the `experimental_onData` callback within the `useChat` hook options:
        ```typescript
        experimental_onData: (dataChunk) => {
          try {
            const parsedData = JSON.parse(dataChunk);
            // Check if it's our custom search data
            if (parsedData.type === 'search-status' || parsedData.type === 'search-results') {
              setCurrentSearchData(parsedData as SearchData);
              console.log("Updated currentSearchData:", parsedData); // Debug log
            }
          } catch (e) { /* Ignore non-JSON chunks */ }
        },
        ```
    -   [ ] Implement the `onFinish` callback within `useChat` hook options:
        ```typescript
        onFinish: (message) => {
          if (currentSearchData && message.role === 'assistant') {
             console.log(`Attaching search data to message ${message.id}`, currentSearchData); // Debug log
             setMessages((prevMessages) =>
               prevMessages.map((m) =>
                 m.id === message.id
                   ? { ...m, data: { ...(m.data || {}), search: currentSearchData } } // Attach search data
                   : m
               ) as Message[] // Cast back to Message[] if needed by setMessages type
             );
             setCurrentSearchData(null); // Reset after attaching
          }
          mutate('/api/history'); // Existing history revalidation
        },
        ```
    -   [ ] Implement `onError` callback within `useChat` to reset state:
        ```typescript
        onError: (error) => {
          toast.error('An error occured, please try again!');
          setCurrentSearchData(null); // Reset search state on error
        },
        ```
    -   [ ] Cast the `messages` array from `useChat` to `MessageWithSearchData[]` before passing it to the `Messages` component.
        ```typescript
        const messagesWithSearchData = messages as MessageWithSearchData[];
        ```
    -   [ ] Pass the `currentSearchData` state to the `Messages` component as a new prop `currentSearchStatus`, but *only* if its type is `search-status`.
        ```typescript
        currentSearchStatus={currentSearchData?.type === 'search-status' ? currentSearchData : null}
        ```

---

## Story 3: Update Message Rendering for Integrated Search

**Context:** The UI needs to display the search progress indicator appropriately and render the `SearchResults` component below the assistant message it belongs to, rather than as a separate block.
**Constraint:** Visual changes should be contained within the message flow.

**Requirements:**
- Display `SearchProgress` component only when a search is actively running *before* the AI response is complete.
- Display `SearchResults` component conditionally *within* the `PreviewMessage` component, specifically for assistant messages that have associated `searchData`.
- Pass the relevant search data down to `PreviewMessage`.

**Tasks:**

-   [ ] **File:** `components/messages.tsx`
    -   [ ] Update the component's props interface to accept `messages: MessageWithSearchData[]` and `currentSearchStatus: SearchData | null`.
    -   [ ] Modify the loop rendering messages:
        ```typescript
        {messagesWithSearchData.map((message, index) => (
          <PreviewMessage
            key={message.id}
            // ... other existing props ...
            message={message} // Pass the full message object
            searchData={message.data?.search} // Pass the attached search data
          />
        ))}
        ```
    -   [ ] Add a section *after* the message loop to render `SearchProgress`:
        ```typescript
        {currentSearchStatus && currentSearchStatus.status !== 'complete' && (
          <motion.div /* ... animation props ... */ className="w-full mx-auto max-w-3xl px-1 sm:px-4">
            <div className="flex gap-2 sm:gap-4 w-full">
              <div className="size-8 shrink-0"></div> {/* Spacer for avatar */}
              <div className="flex-1">
                <SearchProgress
                  status={currentSearchStatus.status}
                  query={currentSearchStatus.query}
                  error={currentSearchStatus.error}
                />
              </div>
            </div>
          </motion.div>
        )}
        ```
    -   [ ] Ensure the `useScrollToBottom` hook still functions correctly with the added `SearchProgress` element.

-   [ ] **File:** `components/message.tsx` (`PreviewMessage` component)
    -   [ ] Update the component's props interface to accept `message: MessageWithSearchData` and `searchData?: SearchData | null`.
    -   [ ] Define a condition to show search results:
        ```typescript
        const showSearchResults = message.role === 'assistant' && searchData && searchData.status === 'complete';
        ```
    -   [ ] Locate the area within the component where the main content (`Markdown`, tool calls, etc.) is rendered.
    -   [ ] Add conditional rendering *after* the main content rendering:
        ```typescript
        {showSearchResults && (
          <SearchResults
            results={searchData.results || []}
            query={searchData.query}
            answer={searchData.answer}
            images={searchData.images}
            responseTime={searchData.responseTime}
            className="mt-3" // Add margin top for spacing
          />
        )}
        ```
    -   [ ] Remove any existing logic that might render `SearchProgress` *inside* `PreviewMessage`.

---

## Story 4: Refine Search Results Component UI

**Context:** The `SearchResults` component needs a visual overhaul to match the Grok 3 reference, displaying summary, images, and sources clearly and concisely.
**Constraint:** Utilize existing `shadcn/ui` components and Tailwind CSS classes.

**Requirements:**
- Display a clear header with the query, search icon, and potentially response time.
- Include a "Powered by Tavily" link.
- Implement expand/collapse functionality for detailed results.
- Display the `answer` (summary) prominently if available.
- Display `images` (if available) in a compact horizontal layout.
- List `results` (sources) clearly with numbers, linked titles, and truncated URLs.
- Hide detailed `content` snippets by default within the collapsed view.
- Show detailed results (content, score, date) only when expanded.
- Style consistently with the application's theme.

**Tasks:**

-   [ ] **File:** `components/search-results.tsx`
    -   [ ] Add `useState` for `expanded` state, default `false`.
    -   [ ] Create the main container `div` with `border`, `rounded-lg`, `overflow-hidden`, `bg-white dark:bg-zinc-900`.
    -   [ ] **Header Section:**
        -   [ ] Use `flex justify-between items-center` with appropriate background (`bg-sky-500/10`) and padding (`p-3`).
        -   [ ] Left side: `flex items-center gap-2` with `Globe` icon, query text (`font-medium`), and optional `responseTime`.
        -   [ ] Right side: `flex items-center gap-2` with "Powered by Tavily" link (`<a>` tag, `text-xs`, `text-sky-500`, `hover:underline`, `flex items-center gap-1`, `ExternalLink` icon) and the expand/collapse `button` (`ChevronUp`/`ChevronDown`, `p-1`, `rounded`, `hover:bg-sky-500/10`).
    -   [ ] **Answer/Summary Section:**
        -   [ ] Conditionally render a `div` (`p-3 border-b bg-sky-500/5`) if `answer` exists.
        -   [ ] Add a label "Summary:" (`text-sm font-medium mb-1`).
        -   [ ] Display the `answer` text (`text-sm`).
    -   [ ] **Images Section:**
        -   [ ] Conditionally render a `div` (`p-3 border-b`) if `images && images.length > 0`.
        -   [ ] Add a label "Related Images:" (`text-sm font-medium mb-2`).
        -   [ ] Use `flex flex-wrap gap-2` to display images.
        -   [ ] Limit the number of images shown initially (e.g., `images.slice(0, 3)`).
        -   [ ] Use `next/image` for each image (`relative group size-24`, `object-cover`, `rounded-md`). Implement `fill` and `sizes`.
        -   [ ] Add an optional overlay for `description` on hover.
    -   [ ] **Sources Section:**
        -   [ ] Render a `div` (`p-3 border-b`).
        -   [ ] Add a header `flex items-center gap-1 mb-2` with `Link2` icon, "Sources:", and helper text "(Click to open)".
        -   [ ] Check if `safeResults.length > 0`.
        -   [ ] If yes, use `grid grid-cols-1 sm:grid-cols-2 gap-2` to display sources.
        -   [ ] For each source `a` tag:
            *   Set `href`, `target`, `rel`.
            *   Add `id={`source-${index + 1}`}` and `data-source-id={index + 1}`.
            *   Apply styling: `text-xs`, background/hover states (`bg-sky-50 ...`), padding, rounding, etc.
            *   Use `flex items-center gap-1` inside the link.
            *   Display the numbered badge (`span` with background, rounded, size).
            *   Display the `title` (`font-medium`, `truncate`).
            *   Display the `url` (`text-gray-500`, `truncate`).
            *   Add `ExternalLink` icon (`ml-auto flex-shrink-0`).
        -   [ ] If no results, display a placeholder message (`flex items-center justify-center p-4 bg-gray-50 ...`).
    -   [ ] **Expanded Details Section:**
        -   [ ] Conditionally render a `div` (`max-h-80 overflow-y-auto`) if `expanded && safeResults.length > 0`.
        -   [ ] Map through `safeResults` again.
        *   [ ] Create a container `div` for each result (`p-3 border-b last:border-b-0 ...`).
        *   [ ] Display `title` (linked), `url`, `score`, `publishedDate`.
        *   [ ] Display the detailed `content`.
    -   [ ] **Collapse Hint:**
        -   [ ] Conditionally render a button/text (`p-2 text-center text-xs ...`) if `!expanded && safeResults.length > 0` to allow expanding.

---

## Story 5: Implement Inline Citation Rendering

**Context:** The AI will now generate responses containing markdown links like `[Source Title](URL)`. The frontend needs to parse these and render them using the `SourceReference` component.
**Constraint:** Must correctly identify the specific citation format and not interfere with regular markdown links.

**Requirements:**
- Identify markdown links that represent source citations.
- Extract the source ID (or potentially title/URL directly if AI provides it, though ID matching is more robust).
- Replace the markdown link text with the `SourceReference` component during rendering.

**Tasks:**

-   [ ] **File:** `components/source-reference.tsx`
    *   [ ] Ensure the component primarily uses `sourceId` to function.
    *   [ ] Keep the logic to *attempt* fetching title/URL from the DOM using `document.getElementById(source-${sourceId})` as a fallback *only if* title/URL props are not provided (acknowledge this might be less reliable).
    *   [ ] Style the component to look like a small, clickable badge/pill containing the source number and potentially the title on hover/expansion. Include an `ExternalLink` icon.
-   [ ] **File:** `lib/utils.ts` (or similar utility location)
    *   [ ] Verify/refine the `processSourceReferences` function.
    *   [ ] Ensure the regex `/\[Source\s+(\d+(?:,\s*\d+)*)\]/g` is used to capture single or multiple comma-separated source IDs.
    *   [ ] Inside the loop/map processing matches:
        *   Split the captured IDs string (e.g., "1, 2") by comma.
        *   Trim whitespace from each ID and parse it as an integer.
        *   For each valid ID, create and push a `<SourceReference key={...} sourceId={id} />` element to the `parts` array.
        *   If multiple IDs were captured in one match, add appropriate separators (e.g., `, `) between the rendered `SourceReference` components in the `parts` array.
-   [ ] **File:** `components/markdown.tsx`
    *   [ ] In the `components` override for `p`:
        *   Receive `children`.
        *   Convert `children` to an array: `React.Children.toArray(children)`.
        *   Iterate through the array. If an element is a string containing `[Source`, call `processSourceReferences` on that string segment.
        *   Otherwise, keep the element as is.
        *   Flatten the resulting array of strings and React elements.
        *   Render the flattened array within the `<p>` tag.
    *   [ ] Ensure regular markdown links (`[text](url)`) are still rendered correctly by the default `a` component or a custom one if overridden.

---

## Story 6: Ensure Robustness and Non-Regression

**Context:** Major changes to core components require thorough testing to ensure no existing features are broken.
**Constraint:** All previous functionalities must remain operational.

**Requirements:**
- Verify core chat works without search.
- Verify artifact generation/interaction works.
- Verify authentication works.
- Verify file uploads work.
- Verify payment/subscription flows work (if applicable to UI changes).
- Test error handling scenarios for web search.
- Ensure UI is responsive.

**Tasks:**

-   [ ] **Manual Testing:**
    -   [ ] Perform a standard chat session *without* enabling web search. Verify normal responses.
    -   [ ] Create and interact with each artifact type (text, code, image, sheet). Verify functionality.
    -   [ ] Initiate a chat session *with* web search enabled.
        -   [ ] Use a query likely to *not* trigger search (e.g., "hello"). Verify no search occurs.
        -   [ ] Use a query likely to trigger search (e.g., "latest news about AI").
        -   [ ] Observe the `SearchProgress` indicator appearing below the message list.
        -   [ ] Verify the final AI response incorporates information from the search.
        -   [ ] Verify inline citations `[Title](URL)` appear within the AI response.
        -   [ ] Verify the `SearchResults` component appears *below* the AI response content.
        -   [ ] Click on source links in `SearchResults` - verify they open correctly.
        -   [ ] Click on inline `SourceReference` components - verify they link correctly (or show tooltip if that's the design).
        -   [ ] Expand/collapse the `SearchResults` details.
    -   [ ] Test login/logout with email/password.
    -   [ ] Test login/logout with Google OAuth.
    -   [ ] Test uploading a file during a chat.
    -   [ ] If possible, simulate a Tavily API error (e.g., by temporarily removing the API key) and verify the error status is shown correctly and the AI responds appropriately.
    -   [ ] Test the UI on different screen sizes (desktop, tablet, mobile).
    -   [ ] Review browser developer console for any new errors or warnings during testing.
    -   [ ] Check chat history - ensure messages (including those with search data) are saved and loaded correctly.

---

**Completion Criteria:** Web search results are seamlessly integrated into the AI response flow, matching the target UI reference, with inline citations rendered correctly, and no regression in existing application functionality.
```